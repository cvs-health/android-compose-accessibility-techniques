<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Compose 접근성 기술 모음집</string>
    <string name="navigate_up">뒤로</string>
    <string name="collapse_button_description">접기</string>
    <string name="expand_button_description">펼치기</string>
    <string name="standalone_link_on_click_label">브라우저로 열기</string>
    <string name="textfield_clear_button_description">텍스트 비우기</string>

    <!-- HomeScreen -->
    <string name="home_title">홈</string>
    <string name="home_description">이 애플리케이션은 Jetpack Compose 기반 UI에 관하여 다양한 접근성 모범 사례와 이를 통해 해결할 수 있는 문제 예시를 보여줍니다.</string>
    <string name="home_description_2">아래 카드를 사용하여 주제 영역을 선택하고 해당 시연에 사용된 보조 기술에 관한 화면 속 지시 사항을 따르세요.</string>
    <string name="home_informative_content">정보성 콘텐츠</string>
    <string name="home_interactive_behaviors">상호작용 동작</string>
    <string name="home_components">특정 컴포넌트 유형</string>
    <string name="home_navigation_click_label">자세히 보기</string>

    <!-- Text alternatives -->
    <string name="text_alternatives_title">대체 텍스트</string>
    <string name="text_alternatives_heading">텍스트가 아닌 콘텐츠에 관한 적절한 대체 텍스트 제공</string>
    <string name="text_alternatives_description_1">정보성을 띄는 모든 콘텐츠는 보편적으로 contentDescription 속성을 통해 그에 맞는 적절한 대체 텍스트를 제공해야 합니다. 순전히 장식을 목적으로 하는 경우 contentDescription을 null로 제공할 수 있습니다.</string>
    <string name="text_alternatives_description_2">인접한 텍스트 콘텐츠와 중복되는 유익한 비 텍스트 콘텐츠는 해당 텍스트 콘텐츠와 그룹화하여 contentDescription을 null로 부여하여 중복된 내용을 최소화해야 합니다. 아래의 예시 4를 참조하십시오.</string>
    <string name="text_alternatives_description_3">TalkBack을 켜고, 화면 예시 요소를 읽어보세요.</string>
    <string name="text_alternatives_example_1_heading">안 좋은 예시 1: 일출 및 일몰 시간 아이콘에 대체 텍스트가 없음</string>
    <string name="text_alternatives_example_sunrise_time">오전 6:24</string>
    <string name="text_alternatives_example_sunset_time">오후 5:35</string>
    <string name="text_alternatives_example_2_heading">무난한 예시 2: 일출 및 일몰 시간 아이콘에 대체 텍스트를 제공함</string>
    <string name="text_alternatives_example_sunrise_description">일출</string>
    <string name="text_alternatives_example_sunset_description">일몰</string>
    <string name="text_alternatives_example_3_heading">좋은 예시 3: 일출 및 일몰 시간과 아이콘을 그룹화함</string>
    <string name="text_alternatives_example_4_heading">좋은 예시 4: 일출 및 일몰 시간과 아이콘 중복 텍스트를 그룹화함</string>
    <string name="text_alternatives_example_4_note">참고사항으로 이 앱의 거의 모든 예제 제목은 유사한 기술을 사용합니다.</string>
    <string name="text_alternatives_example_5_heading">좋은 예시 5: 일출 및 일몰 시간과 아이콘을 하나의 대체 텍스트로 합침</string>
    <string name="text_alternatives_example_5_grouped_sunrise_text">오전 6:24에 해가 뜸</string>
    <string name="text_alternatives_example_5_grouped_sunset_text">오후 5:35에 해가 짐</string>
    <string name="text_alternatives_example_6_heading">안 좋은 예시 6: \'공유하기\' 아이콘 버튼에 빈 대체 텍스트가 있음</string>
    <string name="text_alternatives_example_6_message">대체 텍스트가 비어있는 공유하기 아이콘을 눌렀습니다.</string>
    <string name="text_alternatives_example_6_note">대체 텍스트가 비어있는 \'공유하기\' 아이콘은 TalkBack으로 선택할 수 없습니다.</string>
    <string name="text_alternatives_example_7_heading">안 좋은 예시 7: \'공유하기\' 아이콘 버튼의 contentDescription이 null임</string>
    <string name="text_alternatives_example_7_message">대체 텍스트가 null로 제공된 공유하기 아이콘 버튼을 눌렀습니다.</string>
    <string name="text_alternatives_example_8_heading">좋은 예시 8: \'공유하기\' 아이콘 버튼에 대체 텍스트 제공</string>
    <string name="text_alternatives_example_8_content_description">공유하기</string>
    <string name="text_alternatives_example_8_message">대체 텍스트가 제공된 공유하기 아이콘 버튼을 눌렀습니다.</string>
    <string name="text_alternatives_example_9_heading">안 좋은 예시 9: 장식용 이미지에 빈 대체 텍스트가 있음</string>
    <string name="text_alternatives_example_9_decorated_text">장식용 텍스트 예시입니다.</string>
    <string name="text_alternatives_example_10_heading">나쁜 예시 10: 의미 없는 장식용 이미지에 대체 텍스트가 있음</string>
    <string name="text_alternatives_example_10_content_description">새싹</string>
    <string name="text_alternatives_example_10_decorated_text">장식용 텍스트 예시입니다.</string>
    <string name="text_alternatives_example_11_heading">좋은 사례 11: 장식용 이미지에 contentDescription을 null로 제공</string>
    <string name="text_alternatives_example_11_decorated_text">장식용 텍스트 예시입니다.</string>
    <string name="text_alternatives_example_12_heading">나쁜 예시 12: 그룹화된 장식용 이미지의 contentDescription이 비어 있음</string>
    <string name="text_alternatives_example_12_description">
이미지에 빈 contentDescription을 사용하는 것은 TalkBack에서 \"레이블이 지정되지 않음. 이미지\"가 발표되지 않기 때문에 코드가 어떻게 작성되었는지 숨깁니다. 하지만 이는 나쁜 코드로 여겨지며 자동 UI 테스트에 사용되는 시맨틱론적 트리를 변경합니다.</string>
    <string name="text_alternatives_example_12_decorated_text">장식용 텍스트 예시입니다.</string>
    <string name="text_alternatives_example_13_heading">무난한 예시 13: 그룹화된 장식용 이미지에 invisibleToUser() 적용</string>
    <string name="text_alternatives_example_13_content_description">새싹</string>
    <string name="text_alternatives_example_13_decorated_text">장식용 텍스트 예시입니다.</string>
    <string name="text_alternatives_example_14_heading">좋은 예시 14: 그룹화된 장식 이미지에 contentDescription을 null로 제공</string>
    <string name="text_alternatives_example_14_decorated_text">장식용 텍스트 예시입니다..</string>
    <!-- Accessibility traversal order -->
    <string name="accessibility_traversal_order_title">접근성 순회 순서</string>
    <string name="accessibility_traversal_order_heading">접근성 순회 순서는 논리적이여야 한다</string>
    <string name="accessibility_traversal_order_description_1">접근성 순회 순서(예: TalkBack이 콘텐츠를 탐색하는 순서)는 왼쪽에서 오른쪽, 위에서 아래로 읽게끔 정해져있다. Modifier.semantics의 속성인 isTraversalGroup과 traversalIndex는 탐색하는 순서를 바꾸는 용도로 사용할 수 있다.</string>
    <string name="accessibility_traversal_order_description_2">TTalkBack을 켜고 화면을 통해 예시를 탐색해 보세요.</string>
    <string name="accessibility_traversal_order_example_1_heading">안 좋은 예시 1: 비논리적인 텍스트 탐색 순서</string>
    <string name="accessibility_traversal_order_example_1_description">주요 텍스트 블록은 사이드바 텍스트 열이 옆에 표시된 화면 너비의 2/3 열입니다. TalkBack은 각 열을 순서대로 읽어야 하지만, 대신 메인 텍스트와 사이드바 텍스트를 비논리적으로 혼합하여 왼쪽에서 오른쪽으로, 위에서 아래로 각 텍스트 블록을 읽습니다.</string>
    <string name="accessibility_traversal_order_example_group_1_label">주요 텍스트</string>
    <string name="accessibility_traversal_order_example_group_1_text_a">주요 텍스트 블록의 첫번째 문단입니다.</string>
    <string name="accessibility_traversal_order_example_group_1_text_b">주요 텍스트 블록의 두번째 문단입니다.</string>
    <string name="accessibility_traversal_order_example_group_1_text_c">주요 텍스트 블록의 세번째 문단입니다.</string>
    <string name="accessibility_traversal_order_example_group_2_label">사이드바</string>
    <string name="accessibility_traversal_order_example_group_2_text_a">첫번째 사이드바 문단입니다.</string>
    <string name="accessibility_traversal_order_example_group_2_text_b">두번째 사이드바 문단입니다.</string>
    <string name="accessibility_traversal_order_example_2_heading">좋은 예시 1: isTraversalGroup을 통해 논리적 순회 순서로 배열된 텍스트</string>
    <string name="accessibility_traversal_order_example_2_description">TalkBack은 TraversalGroup이 텍스트를 적절하게 그룹화하기 때문에 사이드바 텍스트보다 먼저 이 예제의 각 메인 텍스트를 완전히 읽습니다.</string>
    <string name="accessibility_traversal_order_example_2_afterword">2개의 열 영역 다음에 오는 텍스트입니다.</string>
    <string name="accessibility_traversal_order_example_3_heading">좋은 예시 2: traversalIndex을 통해 다른 순서로 배열된 텍스트</string>
    <string name="accessibility_traversal_order_example_3_description">TalkBack은 이 예제의 각 사이드바 텍스트를 기본 텍스트보다 먼저 읽습니다. 왜냐하면 is TraversalGroup이 이 예제를 수집하고 traversalIndex가 사이드바를 먼저 정렬하기 때문입니다. traversalIndex의 효과를 동봉된 열로만 제한하려면 해당 콘텐츠를 감싸는 행에도 TraversalGroup으로 설정해야 합니다.</string>
    <string name="accessibility_traversal_order_example_3_afterword">2개의 열 영역 다음에 오는 텍스트입니다.</string>

    <!-- Content grouping -->
    <string name="content_grouping_title">콘텐츠 그룹화</string>
    <string name="content_grouping_heading">일부 콘텐츠는 스크린 리더를 위해 그룹화할 필요가 있습니다.</string>
    <string name="content_grouping_description">일부 텍스트, 특히, 간단한 테이블, 카드, 목록 항목은 분할된 텍스트로 합성되어 있어도 스크린 리더에서 하나의 블럭으로 읽어야 합니다. 이를 통해 스크린 리더 사용자는 각 텍스트를 개별적으로 듣는 대신에 한번에 정보를 들을 수 있으며, 다음 내용 블록으로 빠르게 건너뛸 수 있습니다. 카드 또는 목록 항목을 클릭할 수 있는 경우 자동으로 처리되며, 그렇지 않으면 수동으로 처리해야 합니다.</string>
    <string name="content_grouping_description_2">TalkBack을 켜고 다음 항목을 들어 시연해 보세요.</string>
    <string name="content_grouping_table_examples">간단한 표 예제</string>
    <string name="content_grouping_table_example_1">안 좋은 예시 1: 그룹화하지 않은 테이블</string>
    <string name="content_grouping_table_example_2">안 좋은 예시 2: 잘못 그룹화된 테이블</string>
    <string name="content_grouping_table_example_3">좋은 예시 3: 적절히 그룹화된 테이블</string>
    <string name="content_grouping_table_example_header_1">도시명</string>
    <string name="content_grouping_table_example_header_2">인구</string>
    <string name="content_grouping_table_example_header_3">지역 (제곱마일)</string>
    <string name="content_grouping_table_example_value_1">보스턴</string>
    <string name="content_grouping_table_example_value_2">675,647</string>
    <string name="content_grouping_table_example_value_3">48.4</string>
    <string name="content_grouping_card_examples">카드 예시</string>
    <string name="content_grouping_card1_title">안 좋은 예시 4: 그룹화되지 않은 카드 콘텐츠</string>
    <string name="content_grouping_card1_author">첫번째 저자</string>
    <string name="content_grouping_card1_date">2024년 1월</string>
    <string name="content_grouping_card1_description">이 카드는 스크린 리더를 위해 내용을 그룹화하지 않습니다. 각각의 개별 텍스트를 스와이프해야 한다는 점에 유의하세요.</string>
    <string name="content_grouping_card2_title">좋은 예시 5: 그룹화된 카드 콘텐츠</string>
    <string name="content_grouping_card2_author">두번째 저자</string>
    <string name="content_grouping_card2_date">2020년 3월</string>
    <string name="content_grouping_card2_description">이 카드는 Modifier.semantics( mergeDescendants = true )를 사용하여 스크린 리더를 위해 콘텐츠를 그룹화합니다. 한 번 스와이프하면 다음 카드로 이동하는 방식에 주목하세요.</string>
    <string name="content_grouping_card3_title">좋은 예시 6: 그룹화된 콘텐츠가 있는 다른 카드</string>
    <string name="content_grouping_card3_author">세번째 저자</string>
    <string name="content_grouping_card3_date">2022년 5월</string>
    <string name="content_grouping_card3_description">이 카드는 클릭할 수 있는 콘텐츠를 그룹화합니다.</string>
    <string name="content_grouping_card3_message">카드를 활성화하면 일반적으로 카드 내용의 상세 보기가 열립니다.</string>

    <!-- Content group replacement -->
    <string name="content_group_replacement_title">그룹화된 콘텐츠을 위한 대체 내용</string>
    <string name="content_group_replacement_heading">그룹화된 콘텐츠는 스크린 리더 사용 경험을 강화하기 위해 내용이 대체할 수 있습니다.</string>
    <string name="content_group_replacement_description">레이아웃 그룹의 그래픽 구성 요소가 단일 텍스트로 그룹화되더라도 스크린 리더에 그 시맨틱를 잘 전달하지 못하는 경우가 있습니다. 이 경우 레이아웃 그룹의 대체 텍스트를 더 나은 설명으로 대체할 수 있습니다.</string>
    <string name="content_group_replacement_description_2">TalkBack을 켜고 이 페이지의 예시 항목들을 시연해 보세요.</string>
    <string name="content_group_replacement_ungrouped_rating_heading">안 좋은 예시 1: 그룹화되지 않은 별점 콘텐츠</string>
    <string name="content_group_replacement_rating_group_heading">안 좋은 예시 2: 그룹화된 별점 콘텐츠</string>
    <string name="content_group_replacement_rating_group_note">LinearProgressIndicator의 행을 시맨틱론적으로 병합했음에도 불구하고 TalkBack에서 초점이 여러개로 나눠지는 것을 주목하세요.</string>
    <string name="content_group_replacement_rating_group_replaced_heading">좋은 예시 3: 그룹화된 콘텐츠와 별점를 invisibleToUser()로 대체함</string>
    <string name="content_group_replacement_rating_group_overridden_heading">좋은 예시 4: 그룹화된 콘텐츠와 별점을 clearAndSetSemantics로 대체함</string>
    <string name="content_group_replacement_rating_label">별점: </string>
    <string name="content_group_replacement_rating_text">%1$s / %2$s</string>
    <string name="content_group_replacement_reviews">리뷰 %1$d개</string>
    <plurals name="content_group_replacement_rating_group_content_description">
        <item quantity="other">총 별점: %2$s개 중 %1$s개, %3$d개의 리뷰</item>
    </plurals>

    <!-- Heading semantics -->
    <string name="heading_semantics_title">제목 시맨틱</string>
    <string name="heading_semantics_heading">제목 텍스트는 Accessibility Heading(이하, 접근성 제목)으로 처리되어야 합니다.</string>
    <string name="heading_semantics_description_1"> 접근성 제목은 스크린 리더에게 해당 텍스트가 제목 요소임을 알립니다. 또한 스크린 리더 사용자가 제목 단위로 빠른 탐색을 할 수 있게 지원합니다.</string>
    <string name="heading_semantics_description_2">TalkBack을 켜고 다음 예시 텍스트를 읽어보세요. 세 손가락 위 아래, 또는 왼쪽, 오른쪽으로 쓸기 동작을 통해 읽기 컨트롤을 "제목"으로 전환하여 아래와 위로 스와이프하면 제목 단위 탐색을 경험할 수 있습니다.</string>
    <string name="heading_semantics_example_1_heading">안 좋은 예시 1: 큰 텍스트이지만 제목이 아님</string>
    <string name="heading_semantics_example_1_body_text">눈으로 보기에 큰 텍스트는 그 자체로 접근성 목적의 제목으로 작동하지 않습니다. 제목으로 표시되어야 합니다.</string>
    <string name="heading_semantics_example_2_heading">안 좋은 예시 2: \'제목\'을 contentDescription 마지막에 넣는다고 제목으로 인식되진 않음</string>
    <string name="heading_semantics_faux_heading_content_description">%1$s, 제목.</string>
    <string name="heading_semantics_example_2_body_text">\"제목\"을 contentDescription에 넣는 것은 텍스트로서 추가되는 것이며 시맨틱론적으로 접근성 제목으로 인식되지 않습니다. TalkBack은 위에 있는 큰 텍스트를 \"제목\"으로 알립니다, 하지만 TalkBack의 읽기 컨트롤에서는 이를 "제목" 유형으로 인식하지 못합니다.</string>
    <string name="heading_semantics_example_3_heading">좋은 예시 3: semantics의 heading() 속성 선언</string>
    <string name="heading_semantics_example_3_body_text">컴퍼져블 요소는 Modifier.semantics heading() 속성을 추가하는 것으로 해당 요소를 접근성 제목으로 여겨지게 수 있습니다.</string>

    <!-- List semantics -->
    <string name="list_semantics_title">목록 시맨틱</string>
    <string name="list_semantics_heading">시각적인 목록을 시맨틱으로 접근 가능한 목록으로 만들기</string>
    <string name="list_semantics_description_1">LazyColumn 및 LazyRow로 만든 목록은 TalkBack과 같은 접근성 서비스에 자동으로 목록 시맨틱를 제공하여 “목록에 있음” / “목록에서 벗어남” 및 “총 5개 중 1번째” 등을 읽어줍니다. 그러나 Column 또는 Row로 만든 시각적 목록에는 collectionInfo와 collectionItemInfo semantics 속성을 통해 목록 시맨틱를 추가해야 합니다.</string>
    <string name="list_semantics_description_2">TalkBack을 켜고 스와이프하여 목록 시맨틱가 적용된 경우와 그렇지 않은 시각적 목록 예시를 체험해보세요</string>
    <string name="list_semantics_bullet_point_alt_text">글머리 기호.</string>
    <string name="list_semantics_example_1">안 좋은 예시 1: 목록 시맨틱가 적용되지 않은 시각적 목록</string>
    <string name="list_semantics_bad_point_1">안 좋은 예시, 1포인트</string>
    <string name="list_semantics_bad_point_2">안 좋은 예시, 2포인트</string>
    <string name="list_semantics_bad_point_3">안 좋은 예시, 3포인트</string>
    <string name="list_semantics_after_bad_example">목록 시맨틱가 부여되지 않은 시각적 목록 뒤 텍스트입니다.</string>
    <string name="list_semantics_example_2">좋은 예시 2: 목록 시맨틱가 부여된 순서 없는 목록</string>
    <string name="list_semantics_good_point_1">좋은 예시, 1포인트</string>
    <string name="list_semantics_good_point_2">좋은 예시, 2포인트</string>
    <string name="list_semantics_good_point_3">좋은 예시, 3포인트</string>
    <string name="list_semantics_after_list">목록 시맨틱가 부여된 순서가 없는 시각적 목록 뒤 텍스트입니다.</string>
    <string name="list_semantics_example_3">좋은 예시 3: 시맨틱가 부여된 순서가 있는 목록</string>
    <string name="list_semantics_good_point_1_numbered">1. 순서가 있는 좋은 예시, 1 포인트</string>
    <string name="list_semantics_good_point_2_numbered">2. 순서가 있는 좋은 예시, 2 포인트</string>
    <string name="list_semantics_good_point_3_numbered">3. 순서가 있는 좋은 예시, 3 포인트</string>
    <string name="list_semantics_after_list_2">목록 시맨틱가 부여된 순서가 있는 시각적 목록 뒤 텍스트입니다.</string>
    <string name="list_semantics_example_4">좋은 예시 4: 자동으로 목록 시맨틱가 부여된 LazyRow 목록</string>
    <string name="list_semantics_lazyrow_1">LazyRow 1</string>
    <string name="list_semantics_lazyrow_2">LazyRow 2</string>
    <string name="list_semantics_lazyrow_3">LazyRow 3</string>
    <string name="list_semantics_lazyrow_4">LazyRow 4</string>
    <string name="list_semantics_lazyrow_5">LazyRow 5</string>
    <string name="list_semantics_lazyrow_6">LazyRow 6</string>
    <string name="list_semantics_after_list_3">LazyRow 목록 뒤 텍스트입니다.</string>

    <!-- Adaptive layouts -->
    <string name="adaptive_layouts_title">적응형 레이아웃</string>
    <string name="adaptive_layouts_heading">화면 레이아웃은 화면 크기에 맞게 조정해야 합니다</string>
    <string name="adaptive_layouts_description_1">모든 화면은 디바이스 방향 변경에 따라 화면을 재배치하도록 요구됩니다. 레이아웃 변경이 발생하는 경우, 디바이스 방향 또는 이용가능한 디스플레이 화면 공간에 기초하여 수행될 수 있습니다. 이용가능한 디스플레이 공간에 적응하는 레이아웃들이 강력하게 선호됩니다.</string>
    <string name="adaptive_layouts_description_2">이 화면의 카드가 어떻게 배치되는지 주목하세요. 장치의 방향을 세로 모드와 가로 모드 간 변경 시 카드 배치가 어떻게 변하는지 관찰하세요. 또한 더 큰 태블릿 장치에서 이 화면을 사용해 보세요.</string>
    <string name="adaptive_layouts_example_1_heading">무난한 예시 1: 방향에 따른 적응형 레이아웃</string>
    <string name="adaptive_layouts_example_1_description">이 예에서, 레이아웃은 디바이스 방향에 의해 결정됩니다. 그러나, 이 설정은 이용 가능한 실제 디스플레이 공간을 반영하지 않습니다. 태블릿 디바이스, 폴더블, 및 멀티 윈도우 모드에서 깨지기 쉽습니다.</string>
    <string name="adaptive_layouts_example_2_heading">좋은 예시 2: WindowSizeClass를 사용한 적응형 레이아웃</string>
    <string name="adaptive_layouts_example_2_description">이 예에서 레이아웃은 WindowsSizeClass에 의해 추상화된 실제 사용 가능한 디스플레이 공간에 의해 결정됩니다. 이 기술을 사용하는 레이아웃은 더 많은 상황에 더 잘 적응합니다.</string>
    <string name="adaptive_layouts_pane_1_title">카드 1</string>
    <string name="adaptive_layouts_pane_1_description">첫번째 카드 콘텐츠입니다.</string>
    <string name="adaptive_layouts_pane_2_title">카드 2</string>
    <string name="adaptive_layouts_pane_2_description">두번째 카드 콘텐츠입니다.</string>
    <string name="adaptive_layouts_pane_3_title">카드 3</string>
    <string name="adaptive_layouts_pane_3_description">세번째 카드 콘텐츠입니다.</string>

    <!-- Dark and light themes -->
    <string name="dark_theme_title">어두운 테마와 밝은 테마</string>
    <string name="dark_theme_heading">밝은 테마와 어두운 테마 함께 지원하기</string>
    <string name="dark_theme_description_1">다양한 사용자와 상황에 따라 다른 화면 표시 색상이 필요합니다. 일부 사용자는 빛에 민감하여 항상 어두운 테마를 필요로 하고, 또 다른 사용자는 텍스트를 명확하게 보려면 밝은 테마를 필요로 합니다. 유사하게, 많은 사용자는 어두운 설정에서는 어두운 테마를, 밝은 설정에서는 밝은 테마를 선호할 수 있습니다. 충분히 대조되는 색상으로 두 테마를 모두 지원하는 것이 중요합니다.</string>
    <string name="dark_theme_description_2">색상 값은 Color.kt에서 설정됩니다. 애플리케이션의 테마는 Theme.kt에 정의되며 시스템 어두운 테마 설정에 따라 조건부로 지정됩니다. 이 테마는 MainActivity.kt의 모든 디스플레이를 래핑하는 데 사용됩니다.</string>
    <string name="dark_theme_description_3">디바이스 설정 앱에서 디스플레이를 선택한 다음 어두운 테마 스위치를 토글합니다. 이 앱으로 돌아와서 색상이 변경되었는지 확인합니다. 휴대폰 기종에 따라 이 설정 방법은 상이할 수 있습니다.</string>

    <!-- Screen and pane titles -->
    <string name="screen_and_pane_titles_title">화면 및 창 제목</string>
    <string name="screen_and_pane_titles_heading">화면과 창에는 제목이 필요합니다.</string>
    <string name="screen_and_pane_titles_description_1">모든 화면이나 화면속 창은 사용자가 앱 내에서 방향을 잡을 수 있도록 설명하는 제목이 필요합니다.</string>
    <string name="screen_and_pane_titles_description_2">시각적으로 화면 제목을 제공하려면 화면 Scaffold 안에 TopAppBar의 title을 적용하여 제공할 수 있습니다. TopAppBar의 제목은 시각적으로 한 줄로만 표시될 수 있음을 참고하세요.</string>
    <string name="screen_and_pane_titles_description_3">적절한 컴포져블이나 화면 Scaffold에 Modifier.semantics paneTitle 속성을 통해 제공된 화면 및 창 제목은 스크린 리더를 통해 읽혀집니다.</string>
    <string name="screen_and_pane_titles_description_4">앱바에 표시되는 화면 제목에 주목합니다. TalkBack을 켜고 다른 화면으로 이동하여 화면 제목 안내 데모를 들어보세요.</string>

    <!-- Interactive control labels -->
    <string name="interactive_control_labels_title">상호작용 컨트롤과 레이블</string>
    <string name="interactive_control_labels_heading">프로그래밍 방식으로 상호작용 컨트롤을 레이블과 연결하기</string>
    <string name="interactive_control_labels_description">TalkBack을 켜고 스와이프하여 프로그램과 연결된 레이블이 있는 경우와 없는 경우의 상호작용 컨트롤 데모 화면을 들어보세요.</string>
    <string name="interactive_control_labels_example_1">안 좋은 예시 1: 연결된 레이블이 없는 텍스트 필드</string>
    <string name="interactive_control_labels_unassociated_textfield_label">텍스트 필드와 연결하지 않은 일반 텍스트</string>
    <string name="interactive_control_labels_example_2">좋은 예시 2: 자동으로 레이블을 연결하고 힌트로 사용하는 텍스트 필드</string>
    <string name="interactive_control_labels_associated_textinput_label">연결된 텍스트 필드 레이블과 힌트</string>
    <string name="interactive_control_labels_example_3">안 좋은 예시 3: 연결된 레이블이 없는 체크박스</string>
    <string name="interactive_control_labels_unassociated_checkbox_label">체크박스와 연결하지 않은 일반 텍스트</string>
    <string name="interactive_control_labels_example_4">좋은 예시 4: 레이블을 연결한 체크박스</string>
    <string name="interactive_control_labels_associated_checkbox_label">체크박스와 연결된 서식 레이블</string>
    <string name="interactive_control_labels_example_5">안 좋은 예시 5: 연결된 레이블이 없는 스위치</string>
    <string name="interactive_control_labels_unassociated_switch_label">스위치와 연결되지 않은 텍스트</string>
    <string name="interactive_control_labels_example_6">좋은 예시 6: 연결된 레이블이 있는 스위치 (텍스트)</string>
    <string name="interactive_control_labels_associated_switch_label">스위치와 연결된 서식 레이블</string>
    <string name="interactive_control_labels_example_7">안 좋은 예시 7: 연결된 레이블 등이 없는 라디오 버튼 그룹</string>
    <string name="interactive_control_labels_unassociated_radio_button_label_1">텍스트가 연결되지 않은 라디오 버튼 1</string>
    <string name="interactive_control_labels_unassociated_radio_button_label_2">텍스트가 연결되지 않은 라디오 버튼 2</string>
    <string name="interactive_control_labels_example_8">좋은 예시 8: 연결된 필드 레이블 등이 있는 라디오 버튼 그룹.</string>
    <string name="interactive_control_labels_radio_button_group_label">라디오 버튼 그룹 레이블</string>
    <string name="interactive_control_labels_associated_radio_button_label_1">라디오 버튼 서식 레이블 1</string>
    <string name="interactive_control_labels_associated_radio_button_label_2">라디오 버튼 서식 레이블 2</string>
    <string name="interactive_control_labels_example_9">좋은 예시 9: 연결된 레이블이 있는 버튼</string>
    <string name="interactive_control_labels_associated_button_label">버튼 레이블</string>
    <string name="interactive_control_labels_associated_button_message">버튼 눌림</string>
    <string name="interactive_control_labels_example_10">안 좋은 예시 10: 연결된 레이블이 없는 슬라이더</string>
    <string name="interactive_control_labels_unassociated_slider_label">슬라이더와 연결하지 않은 서식 레이블</string>
    <string name="interactive_control_labels_example_11">무난한 예시 11: 서식 레이블이 연결된 슬라이더</string>
    <string name="interactive_control_labels_example_11_description">슬라이더는 접근 가능한 레이블을 제공하기 위해 contentDescription을 사용해야 합니다. 슬라이더 컨트롤은 단순히 보이는 텍스트 레이블과 연결될 수 없으므로 보이는 레이블 텍스트와 contentDescription이 모두 필요합니다. contentDescription 뿐만 아니라 보이는 레이블 텍스트도 포함해야 합니다.</string>
    <string name="interactive_control_labels_associated_slider_label">슬라이더 서식 레이블</string>
    <string name="interactive_control_labels_associated_slider_content_description">슬라이더 서식 레이블 (contentDescription에 포함됨)</string>
    <string name="interactive_control_labels_example_12">문제가 되는 예시 12: 연결된 필드 레이블이 있는 범위 슬라이더(RangeSlider)</string>
    <string name="interactive_control_labels_example_12_description">슬라이더와 같이, 또한 범위 슬라이더는 접근 가능한 레이블을 제공하기 위해 contentDescription을 사용해야 합니다. 그러나 RangeSliders는 키보드로 액세스할 수 없습니다.</string>
    <string name="interactive_control_labels_associated_rangeslider_label">범위 슬라이더 서식 제목</string>
    <string name="interactive_control_labels_associated_rangeslider_state_description">%1$d부터 %2$d까지</string>

    <!-- UX change announcements -->
    <string name="ux_change_announcements_title">변경 알림</string>
    <string name="ux_change_announcements_heading">모든 UX 변경 사항 발표 (가능하다면 라이브 영역으로)</string>
    <string name="ux_change_announcements_description">사용자의 조작 또는 자동 업데이트로 인한 모든 UX 변경 사항을 접근성 서비스에 공지해야 합니다. 라이브 영역은 시각적으로 보인다면 포함한 값 변경 사항을 알리지만 숨겼을 때는 공지하지 않습니다. 접근성 알림은 직접 코드로도 할 수 있지만, 그렇게 하는 것은 매우 제한적입니다.</string>
    <string name="ux_change_announcements_description_2">TalkBack을 켜고 아래 컨트롤을 활성화하여 시연합니다.</string>
    <string name="ux_change_announcements_example_1_header">좋은 예시 1: 라이브 영역 시맨틱를 적용한 카운터</string>
    <string name="ux_change_announcements_counter">카운터: %1d</string>
    <string name="ux_change_announcements_increment_counter">카운터 증가</string>
    <string name="ux_change_announcements_reset_counter">카운터 초기화</string>
    <string name="ux_change_announcements_example_2_header">좋은 예시 2: 접근성을 위한 알림과 함께 제공된 볼 수 있는 메시지 알림</string>
    <string name="ux_change_announcements_example_2_show_text">텍스트 보기</string>
    <string name="ux_change_announcements_example_2_hide_text">텍스트 숨기기</string>
    <string name="ux_change_announcements_example_2_text">텍스트 표시됨</string>
    <string name="ux_change_announcements_example_2_text_hidden">텍스트 숨겨짐</string>
    <string name="ux_change_announcements_example_3_header">좋은 예시 3: announceForAccessibility로 대기 표시기 알림</string>
    <string name="ux_change_announcements_example_3_show_waiting_indicator">15초 동안 대기 표시기 표시</string>
    <string name="ux_change_announcements_waiting">Waiting…</string>
    <string name="ux_change_announcements_waiting_completed">대기 끝</string>
    <string name="ux_change_announcements_example_4_header">좋은 예시 4: 대화상자 속 대기 표시기</string>
    <string name="ux_change_announcements_example_4_show_waiting_indicator">15초 동안 대기 대화 상자 표시</string>

    <!-- Keyboard types and options -->
    <string name="keyboard_types_title">키보드 유형과 옵션</string>
    <string name="keyboard_types_heading">입력 데이터를 위한 키보드 유형 및 옵션 매치</string>
    <string name="keyboard_types_description_1">텍스트 입력 필드는 수용하는 데이터에 적합한 키보드 유형 및 옵션으로 구성되어야 합니다. 부적절한 키보드 유형은 데이터 입력을 어렵게 하거나 불가능하게 만들 수 있습니다.</string>
    <string name="keyboard_types_description_2">아래 필드를 선택하여 편집하고 표시된 가상 키보드 유형을 관찰하십시오.</string>
    <string name="keyboard_types_example_1_header">안 좋은 예시 1: 이름 텍스트 데이터 입력을 방해하는 숫자 키보드 유형</string>
    <string name="keyboard_types_example_1_label">이름</string>
    <string name="keyboard_types_example_2_header">안 좋은 예시 2: 전화번호 데이터 유형에 맞지 않는 소수점 키보드 유형</string>
    <string name="keyboard_types_example_2_label">전화번호</string>
    <string name="keyboard_types_example_3_header">좋은 예시 3: 전화번호 입력을 위한 키보드 유형 (Phone)</string>
    <string name="keyboard_types_example_3_label">전화번호</string>
    <string name="keyboard_types_example_4_header">좋은 예시 4: 숫자 입력을 위한 키보드 유형 (Number)</string>
    <string name="keyboard_types_example_4_label">수량</string>
    <string name="keyboard_types_example_5_header">좋은 예시 5: 소수점 숫자 입력을 위한 키보드 유형 (Decimal)</string>
    <string name="keyboard_types_example_5_label">가격</string>
    <string name="keyboard_types_example_6_header">좋은 예시 6: 일반 텍스트 입력을 위한 키보드 유형 (Text)</string>
    <string name="keyboard_types_example_6_label">텍스트</string>
    <string name="keyboard_types_example_7_header">좋은 예시 7: 전체 ASCII 텍스트 입력을 위한 키보드 유형 (Ascii)</string>
    <string name="keyboard_types_example_7_label">ASCII 텍스트</string>
    <string name="keyboard_types_example_8_header">좋은 예시 8: 대문자 단어 입력을 위한 키보드 옵션 (예: 이름)</string>
    <string name="keyboard_types_example_8_label">이름</string>
    <string name="keyboard_types_example_9_header">좋은 예시 9: 자동 교정이 포함된 문장 입력용 키보드 옵션</string>
    <string name="keyboard_types_example_9_label">설명</string>
    <string name="keyboard_types_example_10_header">좋은 예시 10: 자동 교정 없이 문장 입력용 키보드 옵션</string>
    <string name="keyboard_types_example_10_label">설명</string>
    <string name="keyboard_types_example_11_header">좋은 예시 11: 이메일 입력을 위한 키보드 유형 (Email)</string>
    <string name="keyboard_types_example_11_label">이메일</string>
    <string name="keyboard_types_example_12_header">좋은 예시 12: URL 입력을 위한 키보드 유형 (Uri)</string>
    <string name="keyboard_types_example_12_label">URL</string>
    <string name="keyboard_types_example_13_header">좋은 예시 13: 텍스트 암호 입력을 위한 키보드 유형 (Password), 마스킹 포함</string>
    <string name="keyboard_types_example_13_label">암호 (텍스트)</string>
    <string name="keyboard_types_example_14_header">좋은 예시 14: 숫자 암호 입력을 위한 키보드 유형 (NumberPassword), 마스킹 포함</string>
    <string name="keyboard_types_example_14_label">암호 (숫자)</string>
    <!-- Keyboard actions -->
    <string name="keyboard_actions_title">키보드 액션</string>
    <string name="keyboard_actions_heading">입력 필드의 목적 또는 위치에 맞는 키보드 액션 맞추기</string>
    <string name="keyboard_actions_description_1">텍스트 입력 필드는 그 목적이나 화면 위치에 적합한 키보드 액션을 구성해야 합니다. 예를 들어, 검색 필드는 "검색(Search)" 액션을 가져야 하며, 독립 메시지 필드는 "보내기(Send)" 액션을 가져야 합니다. 또는, 양식의 마지막 텍스트 입력 필드는 일반적으로 "완료(Done)" 키보드 액션을 가져야 하며, 앞의 필드들은 "다음(Next)" 액션을 가져야 합니다. 부적절한 키보드 액션은 데이터 입력을 더 어렵게 만들 수 있습니다.</string>
    <string name="keyboard_actions_description_2">아래 필드를 선택하여 편집하고, 표시된 가상 키보드 액션을 관찰한 후, 그 액션을 활성화하여 그 효과를 확인하십시오.</string>
    <string name="keyboard_actions_example_1_header">무난한 예시 1: 새 줄 추가하는 키보드 액션 없음(None)</string>
    <string name="keyboard_actions_example_1_label">이름</string>
    <string name="keyboard_actions_example_2_header">좋은 예시 2: 다음 필드로 이동하는 키보드 액션 다음(Next)</string>
    <string name="keyboard_actions_example_2_label">주소</string>
    <string name="keyboard_actions_example_3_header">좋은 예시 3: 양식을 제출하는 키보드 액션 완료(Done)</string>
    <string name="keyboard_actions_example_3_label">우편번호</string>
    <string name="keyboard_actions_example_3_done_message">키보드 "완료(Done)" 선택됨.</string>
    <string name="keyboard_actions_example_4_header">좋은 예시 4: 메시지를 보내는 키보드 액션 보내기(Send)</string>
    <string name="keyboard_actions_example_4_label">메시지</string>
    <string name="keyboard_actions_example_4_send_message">키보드 "보내기(Send)" 선택됨.</string>
    <string name="keyboard_actions_example_5_header">좋은 예시 5: 쿼리를 제출하는 키보드 액션 검색(Search)</string>
    <string name="keyboard_actions_example_5_label">검색</string>
    <string name="keyboard_actions_example_5_search_message">키보드 "검색(Search)" 선택됨.</string>
    <string name="keyboard_actions_example_6_header">좋은 예시 6: 새로운 뷰를 여는 키보드 액션 이동(Go)</string>
    <string name="keyboard_actions_example_6_label">전화</string>
    <string name="keyboard_actions_example_6_go_message">키보드 "이동(Go)"이 선택됨: %1$s.</string>
    <!-- Keyboard focus order -->
    <string name="keyboard_focus_order_title">키보드 초점 순서</string>
    <string name="keyboard_focus_order_heading">키보드 초점 순서는 논리적이어야 하며 트랩이 없어야 합니다</string>
    <string name="keyboard_focus_order_description_1">키보드 초점 순서는 기본적으로 컴포지션 트리 순서(깊이 우선)로 설정되지만, 항상 시맨틱 있는 초점 순서가 아닐 수 있습니다. 때로는 Modifier.focusRequester 및 .focusProperties를 사용하여 특정 초점 순서를 강제해야 합니다. 그러나 초점 트랩은 피하십시오!</string>
    <string name="keyboard_focus_order_description_2">접근성 탐색 순서는 키보드 초점 순서와 별도로 설정됩니다.</string>
    <string name="keyboard_focus_order_description_3">외부 키보드를 사용하여 이 화면을 순차적으로 탐색하십시오. 또한, TalkBack을 사용하여 화면을 단계적으로 탐색해보세요.</string>
    <string name="keyboard_focus_order_example_1_heading">안 좋은 예시 1: 논리적이지 않은 초점 순서의 컨트롤</string>
    <string name="keyboard_focus_order_example_2_heading">무난한 예시 2: focusProperties로 논리적 초점 순서를 강제하는 컨트롤</string>
    <string name="keyboard_focus_order_example_3_heading">좋은 예시 3: 논리적 초점 순서로 그룹화된 컨트롤</string>
    <string name="keyboard_focus_order_example_group_1">그룹 1</string>
    <string name="keyboard_focus_order_example_group_1_checkbox_a">체크박스 1a</string>
    <string name="keyboard_focus_order_example_group_1_checkbox_b">체크박스 1b</string>
    <string name="keyboard_focus_order_example_group_2">그룹 2</string>
    <string name="keyboard_focus_order_example_group_2_checkbox_a">체크박스 2a</string>
    <string name="keyboard_focus_order_example_group_2_checkbox_b">체크박스 2b</string>
    <string name="keyboard_focus_order_example_4_heading">안 좋은 예시 4: 키보드 초점 트랩</string>
    <string name="keyboard_focus_order_example_4_description">focusProperties를 적절히 설정하지 않으면 초점 순서 루프를 만들 수 있습니다. 아래의 두 번째 버튼은 첫 번째 버튼에서 탭으로 초점이 이동할 수 없으며, 역탭으로도 초점 루프를 벗어날 수 없습니다. 초점 트랩을 벗어나기 위해 위 또는 아래 화살표 키를 사용하십시오.</string>
    <string name="keyboard_focus_order_example_4_button_1">첫 번째 버튼 (키보드 초점 트랩)</string>
    <string name="keyboard_focus_order_example_4_button_2">두 번째 버튼(도달 불가)</string>
    <string name="keyboard_focus_order_example_4_buttton_1_message">예시 4 첫 번째 버튼 클릭됨.</string>
    <string name="keyboard_focus_order_example_4_buttton_2_message">예시 4 두 번째 버튼 클릭됨.</string>
    <!-- Custom keyboard focus indicators -->
    <string name="custom_focus_indicators_title">사용자 지정 초점 표시</string>
    <string name="custom_focus_indicators_heading">사용자 지정 초점 표시로 초점 가시성 향상</string>
    <string name="custom_focus_indicators_description_1">기본적으로 Material Design 구성 요소는 저대비 초점 표시를 가지고 있습니다. 사용자 지정 초점 표시를 사용하여 초점 가시성을 개선할 수 있습니다.</string>
    <string name="custom_focus_indicators_description_2">외부 키보드를 사용하여 이 페이지에서 기본 및 개선된 초점 표시를 확인하십시오.</string>
    <string name="custom_focus_indicators_description_3">(이 기술은 이 앱의 많은 컨트롤에 적용되었습니다.)</string>
    <string name="custom_focus_indicators_example_1_heading">문제가 되는 예시 1: 기본 버튼 초점 표시</string>
    <string name="custom_focus_indicators_example_1_description">이 버튼이 기본 시스템 초점 표시를 사용하기 때문에 WCAG 가이드라인을 기술적으로 준수하지만, 사용자 경험은 좋지 않습니다.</string>
    <string name="custom_focus_indicators_example_1_button">기본 초점 표시</string>
    <string name="custom_focus_indicators_example_1_message">기본 초점 표시를 보여주는 예시 1 버튼이 활성화되었습니다.</string>
    <string name="custom_focus_indicators_example_2_heading">좋은 예시 2: 사용자 지정 버튼 초점 표시</string>
    <string name="custom_focus_indicators_example_2_description">이 예시는 버튼의 border 속성을 사용하여 초점 가시성을 개선한 사용자 지정 초점 표시를 보여줍니다.</string>
    <string name="custom_focus_indicators_example_2_button">사용자 지정 초점 표시</string>
    <string name="custom_focus_indicators_example_2_message">사용자 지정 초점 표시를 보여주는 예시 2 버튼이 활성화되었습니다.</string>
    <string name="custom_focus_indicators_example_3_heading">문제가 되는 예시 3: 기본 아이콘 버튼 초점 표시</string>
    <string name="custom_focus_indicators_example_3_button_description">기본 초점 표시가 있는 공유 아이콘 버튼</string>
    <string name="custom_focus_indicators_example_3_message">기본 초점 표시를 보여주는 예시 3 공유 아이콘 버튼이 활성화되었습니다.</string>
    <string name="custom_focus_indicators_example_4_heading">좋은 예시 4: 사용자 지정 아이콘 버튼 초점 표시</string>
    <string name="custom_focus_indicators_example_4_button_description"> 공유 아이콘 버튼에 사용자 지정 초점 표시</string>
    <string name="custom_focus_indicators_example_4_message">사용자 지정 초점 표시를 보여주는 예시 4 공유 아이콘 버튼이 활성화되었습니다.</string>
    <string name="custom_focus_indicators_example_5_heading"> 문제가 되는 예시 5: 기본 클릭 가능한 카드 초점 표시</string>
    <string name="custom_focus_indicators_example_5_card_title">기본 초점 표시가 있는 클릭 가능한 카드</string>
    <string name="custom_focus_indicators_example_5_card_description"> 기본 OutlinedCard 초점 표시를 보려면 이 카드로 탭하세요.</string>
    <string name="custom_focus_indicators_example_5_message">기본 초점 표시를 보여주는 예시 5 클릭 가능한 카드가 활성화되었습니다.</string>
    <string name="custom_focus_indicators_example_6_heading">좋은 예시 6: 사용자 지정 초점 표시가 있는 클릭 가능한 카드</string>
    <string name="custom_focus_indicators_example_6_card_title">사용자 지정 초점 표시가 있는 클릭 가능한 카드.</string>
    <string name="custom_focus_indicators_example_6_card_description">Modifier.border 속성을 사용하여 구현된 사용자 지정 초점 표시를 보려면 이 카드로 탭하세요.</string>
    <string name="custom_focus_indicators_example_6_message">사용자 지정 초점 표시를 보여주는 예시 6 클릭 가능한 카드가 활성화되었습니다.</string>
    <string name="custom_focus_indicators_example_7_heading">좋은 예시 7: 사용자 지정 표시 초점 표시</string>
    <string name="custom_focus_indicators_example_7_card_title">사용자 지정 표시 초점 표시를 보여주는 클릭 가능한 카드.</string>
    <string name="custom_focus_indicators_example_7_card_description">사용자 지정 표시 초점 표시를 보려면 이 카드로 탭하세요.</string>
    <string name="custom_focus_indicators_example_7_message">사용자 지정 표시 초점 표시를 보여주는 예시 7 클릭 가능한 카드가 활성화되었습니다.</string>
        <!-- Custom click labels -->
    <string name="custom_click_labels_title">사용자 지정 클릭 레이블</string>
    <string name="custom_click_labels_heading">사용자 지정 클릭 액션 레이블로 스크린 리더 사용자 경험 향상</string>
    <string name="custom_click_labels_description_1">TalkBack에서 컨트롤의 클릭 또는 길게 클릭 액션을 설명하는 방법은 부분적으로 더 유용하게 재정의할 수 있습니다. 예를 들어, "더블 탭하여 활성화"를 "더블 탭하여 세부 정보 보기"로 변경할 수 있습니다.</string>
    <string name="custom_click_labels_description_2">TalkBack을 켜고 아래 화면을 탐색하여 사용자 지정 클릭 레이블 데모를 살펴보십시오.</string>
    <string name="custom_click_labels_description_3">또한 클릭 가능한 카드가 "버튼" 역할을 발표하지 않는 점에 유의하십시오. 이러한 카드는 여전히 접근할 수 있으며, Android에서는 클릭 액션이 역할 정보를 제공하기 때문입니다.</string>
    <string name="custom_click_labels_example_1_heading">무난한 예시 1: 기본 클릭 액션 레이블</string>
    <string name="custom_click_labels_example_1_label">기본 클릭 액션 레이블</string>
    <string name="custom_click_labels_example_1_message">기본 클릭 액션 레이블 카드를 활성화하도록 선택되었습니다.</string>
    <string name="custom_click_labels_example_2_heading">좋은 예시 2: 사용자 지정 클릭 액션 레이블</string>
    <string name="custom_click_labels_example_2_label">사용자 지정 클릭 액션 레이블</string>
    <string name="custom_click_labels_example_2_custom_click_label">세부 사항 표시</string>
    <string name="custom_click_labels_example_2_message">사용자 지정 클릭 액션 레이블 카드의 세부 사항을 표시하도록 선택되었습니다.</string>
    <string name="custom_click_labels_example_3_heading">좋은 예시 3: 사용자 지정 버튼 클릭 액션 레이블</string>
    <string name="custom_click_labels_example_3_label">Snackbar 시연</string>
    <string name="custom_click_labels_example_3_custom_click_label">팝업 메시지 표시</string>
    <string name="custom_click_labels_example_3_message">사용자 지정 클릭 액션 레이블이 있는 버튼을 선택하였습니다.</string>
        <!-- Custom state descriptions -->
    <string name="custom_state_descriptions_title">사용자 지정 상태 설명</string>
    <string name="custom_state_descriptions_heading">사용자 지정 상태 설명 레이블로 스크린 리더 사용자 경험 향상</string>
    <string name="custom_state_descriptions_description">TalkBack에서 컨트롤의 상태를 설명하는 방법(예: 체크 박스의 “선택됨” 및 "선택 해제됨")을 보다 유용하도록 재정의할 수 있습니다.</string>
    <string name="custom_state_descriptions_description_2">TalkBack을 켜고 다음 컨트롤을 선택 및 토글하여 데모를 들어보십시오.</string>
    <string name="custom_state_descriptions_example_1_heading">무난한 예시 1: 기본 상태 레이블이 있는 체크박스</string>
    <string name="custom_state_descriptions_default_checkbox">모션 감지기</string>
    <string name="custom_state_descriptions_example_2_heading">좋은 예시 2: 사용자 지정 상태 레이블이 있는 체크박스</string>
    <string name="custom_state_descriptions_customized_checkbox">모션 감지기</string>
    <string name="custom_state_descriptions_checked_label">활성화됨</string>
    <string name="custom_state_descriptions_unchecked_label">비활성화됨</string>
    <string name="custom_state_descriptions_example_3_heading">무난한 예시 3: 기본 상태 레이블이 있는 스위치</string>
    <string name="custom_state_descriptions_default_switch">실드</string>
    <string name="custom_state_descriptions_example_4_heading">좋은 예시 4: 사용자 지정 상태 레이블이 있는 스위치</string>
    <string name="custom_state_descriptions_customized_switch">실드</string>
    <string name="custom_state_descriptions_shields_raised">올려짐</string>
    <string name="custom_state_descriptions_shields_lowered">내려짐</string>
    <!-- Custom accessibility actions -->
    <string name="custom_accessibility_actions_title">사용자 지정 접근성 액션</string>
    <string name="custom_accessibility_actions_heading">사용자 지정 접근성 액션으로 스크린 리더 사용자 경험 간소화</string>
    <string name="custom_accessibility_actions_description_1">TalkBack을 켜고 이 페이지를 스와이프하여 사용자 지정 접근성 액션이 있는 카드와 없는 카드의 데모를 들어보세요. 카드를 클릭하면 스낵바 메시지가 표시됩니다.</string>
    <string name="custom_accessibility_actions_description_2">또는 두 버튼의 선형 스캔을 사용하여 Switch Access를 켜고, 다음 스위치를 사용하여 이 페이지를 이동하면서 선택할 수 있는 요소가 무엇인지 확인하십시오. 좋은 예시 카드에서 선택 스위치를 사용하여 사용자 지정 접근성 액션을 보십시오.</string>
    <string name="custom_accessibility_actions_see_details">세부 사항 보기</string>
    <string name="custom_accessibility_actions_example_1_card_heading">안 좋은 예시 1: 사용자 지정 접근성 액션이 없는 카드</string>
    <string name="custom_accessibility_actions_example_1_card_description">각 버튼이 별도의 항목으로 TalkBack에서 읽힌 후 다음 카드가 읽히는 방식을 주목하세요. TalkBack에서는 이 카드에서 "사용 가능한 액션…"을 읽지 않습니다.</string>
    <string name="custom_accessibility_actions_example_2_card_heading">좋은 예시 2: 사용자 지정 접근성 액션이 있는 카드</string>
    <string name="custom_accessibility_actions_example_2_card_description">카드가 단일 항목으로 읽히는 방식을 주목하세요. 버튼들이 사용자 지정 접근성 액션으로 변환되었으며, TalkBack에서는 "사용 가능한 액션…"이라고 읽고 한 번의 스와이프로 다음 카드로 이동합니다.</string>
    <string name="custom_accessibility_actions_example_3_card_heading">좋은 예시 3: 또 다른 사용자 지정 접근성 액션이 있는 카드</string>
    <string name="custom_accessibility_actions_example_3_card_description">TalkBack에서도 이 카드에서 "사용 가능한 액션…"을 읽습니다. TalkBack 메뉴를 열고 액션 메뉴를 열어 버튼의 액션을 수행하거나 Switch Access로 카드를 선택하십시오. 사용하기 훨씬 편리하지 않나요?</string>
    <string name="custom_accessibility_actions_example_like_button">이 게시물 좋아요</string>
    <string name="custom_accessibility_actions_example_share_button">이 게시물 공유</string>
    <string name="custom_accessibility_actions_example_report_button">이 게시물을 부적절로 신고</string>
    <string name="custom_accessibility_actions_show_details_event">카드 예시 #%1$d의 세부 사항을 보여주도록 선택됨</string>
    <string name="custom_accessibility_actions_like_event">카드 예시 #%1$d를 좋아요로 선택됨</string>
    <string name="custom_accessibility_actions_share_event">카드 예시 #%1$d를 공유하도록 선택됨</string>
    <string name="custom_accessibility_actions_report_event">카드 예시 #%1$d를 부적절로 신고하도록 선택됨</string>
    <!-- Autofill controls -->
    <string name="autofill_title">자동 완성 컨트롤</string>
    <string name="autofill_heading">자동 완성을 사용할 수 있는 경우 적용해야 합니다</string>
    <string name="autofill_description_1">가능한 경우, 텍스트 필드는 중복 데이터 입력을 줄이기 위해 자동 완성 제안을 지원해야 합니다. 적절한 데이터가 구성된 자동 완성 서비스가 장치에 설정되어 있으면, 자동 완성 제안이 일부 보조기술이나 가상 키보드에 팝업으로 나타납니다. 물리적 키보드에서는 사용할 수 없습니다.</string>
    <string name="autofill_description_2">아래 입력 필드를 선택하여 편집하면, 좋은 예시 필드에서 자동 완성 제안이 나타납니다.</string>
    <string name="autofill_example_1_heading">안 좋은 예시 1: 자동 완성이 설정되지 않은 이름 및 이메일 텍스트 필드</string>
    <string name="autofill_example_1_label_1">이름</string>
    <string name="autofill_example_1_label_2">이메일</string>
    <string name="autofill_example_2_heading">좋은 예시 2: 자동 완성이 설정된 이름 및 이메일 텍스트 필드</string>
    <string name="autofill_example_2_label_1">이름</string>
    <string name="autofill_example_2_label_2">이메일</string>
    <!-- Accordion controls -->
    <string name="accordion_title">아코디언 컨트롤</string>
    <string name="accordion_heading">아코디언 컨트롤에 확장 또는 축소 시맨틱 속성이 필요합니다</string>
    <string name="accordion_description_1">아코디언 컨트롤은 해당 상태에 따라 적절한 Modifier.semantics 확장(expand) 또는 축소(collapse) 속성을 선언해야 하며, 이 외에도 토글 탭 액션이 필요합니다.</string>
    <string name="accordion_description_2">이 컨트롤들을 다양하게 코딩할 수 있으나 - 레이아웃 요소 또는 리스트 항목으로 - 모두 확장/축소 상태를 발표하기 위해 추가 시맨틱이 필요합니다.</string>
    <string name="accordion_description_3">TalkBack을 켜고 페이지를 탐색하며 컨트롤을 활성화하여 데모를 보세요. 확장/축소 상태 발표와 특별한 확장/축소 액션을 들어보세요.</string>
    <string name="accordion_section_1">안 좋은 예시 1: 확장/축소 액션이 없는 아코디언</string>
    <string name="accordion_item_1_1">잘못된 아코디언 예시, 항목 1</string>
    <string name="accordion_item_1_2">잘못된 아코디언 예시, 항목 2</string>
    <string name="accordion_item_1_3">잘못된 아코디언 예시, 항목 3</string>
    <string name="accordion_section_2">좋은 예시 2: 확장/축소 액션이 있는 아코디언</string>
    <string name="accordion_item_2_1">올바른 아코디언 예시, 항목 1</string>
    <string name="accordion_item_2_2">올바른 아코디언 예시, 항목 2</string>
    <string name="accordion_item_2_3">올바른 아코디언 예시, 항목 3</string>
    <!-- Checkbox controls -->
    <string name="checkbox_controls_title">체크박스 컨트롤</string>
    <string name="checkbox_controls_heading">체크박스 컨트롤에는 레이블과 Modifier.toggleable이 필요합니다</string>
    <string name="checkbox_controls_description_1">체크박스 컴포저블은 해당 시맨틱을 포함하는 래핑 레이아웃(Modifier.toggleable 및 Role.Checkbox 사용)과 컨트롤 레이블을 제공해야 합니다.</string>
    <string name="checkbox_controls_description_2">TalkBack을 켜고 페이지를 탐색하며 접근 불가능한 체크박스와 접근 가능한 체크박스 그룹의 데모를 보십시오.</string>
    <string name="checkbox_controls_example_1_header"> 안 좋은 예시 1: 접근 불가능한 체크박스</string>
    <string name="checkbox_controls_example_1_label">가짜 체크박스</string>
    <string name="checkbox_controls_example_2_header">좋은 예시 2: 접근 가능한 체크박스</string>
    <string name="checkbox_controls_example_2_label">접근 가능한 체크박스</string>
        <!-- Dropdown selection menus -->
    <string name="dropdown_menus_title">드롭다운 메뉴</string>
    <string name="dropdown_menus_heading">드롭다운 메뉴는 개선될 수 있습니다</string>
    <string name="dropdown_menus_description_1">기본 드롭다운 메뉴 패턴은 대부분 접근 가능한 드롭다운 선택 메뉴를 만듭니다. 하지만 선택 없이 닫기가 어려울 수 있으며, 개선되지 않으면 이 문제는 해결되지 않습니다. 사용자 지정 드롭다운 접근 방식도 접근성이 떨어질 수 있습니다.</string>
    <string name="dropdown_menus_description_2">TalkBack, Switch Access를 켜거나 물리적 키보드를 사용하여 이 페이지를 탐색하고 드롭다운 메뉴 컨트롤을 활성화하고 선택하십시오.</string>
    <string name="dropdown_menus_example_1_heading">문제가 되는 예시 1: 기본 드롭다운 메뉴가 있는 ListItem</string>
    <string name="dropdown_menus_example_1_listitem_heading">기본 드롭다운 메뉴가 있는 ListItem</string>
    <string name="dropdown_menus_example_2_heading">좋은 예시 2: 접근 가능한 드롭다운 메뉴가 있는 ListItem</string>
    <string name="dropdown_menus_example_2_description">접근 가능한 드롭다운 메뉴에는 "닫기" 메뉴 항목이 있으며, 자동으로 키보드 초점을 차지하고, Esc 키를 누르면 닫습니다.</string>
    <string name="dropdown_menus_example_2_listitem_heading">접근 가능한 드롭다운 메뉴가 있는 ListItem</string>
    <string name="dropdown_menus_example_menu_content_description">드롭다운 메뉴 표시</string>
    <string name="dropdown_menus_example_menu_item_1">메뉴 항목 1</string>
    <string name="dropdown_menus_example_menu_item_1_message">메뉴 항목 1 선택됨.</string>
    <string name="dropdown_menus_example_menu_item_2">메뉴 항목 2</string>
    <string name="dropdown_menus_example_menu_item_2_message">메뉴 항목 2 선택됨.</string>
    <string name="dropdown_menus_example_menu_close_item">메뉴 닫기</string>
    <string name="dropdown_menus_example_menu_close_message">메뉴가 닫혔습니다.</string>
        <!-- Exposed dropdown selection menus -->
    <string name="exposed_dropdown_menus_title">노출된 드롭다운 메뉴</string>
    <string name="exposed_dropdown_menus_heading">노출된 드롭다운 메뉴는 키보드로 조작할 수 없습니다</string>
    <string name="exposed_dropdown_menus_description_1">노출된 드롭다운 메뉴 패턴은 대부분 접근 가능한 드롭다운 선택 메뉴를 만듭니다. 그러나 Compose BOM 2024.04.00 기준으로, 어떤 Compose 드롭다운 컨트롤도 키보드로 접근할 수 없으며, 알려진 해결책이 없습니다. 사용자 지정 드롭다운 접근 방식도 더 접근하기 어려울 수 있습니다.</string>
    <string name="exposed_dropdown_menus_description_2">TalkBack 또는 Switch Access를 켜고 이 페이지를 탐색하며 리스트 컨트롤을 활성화하고 선택하십시오. 그런 다음 물리적 키보드를 사용하여 문제를 관찰해보세요.</string>
    <string name="exposed_dropdown_menus_example_1_heading">문제가 되는 예시 1: 편집 불가능한 노출된 드롭다운 메뉴</string>
    <string name="exposed_dropdown_menus_example_1_description">노출된 드롭다운 메뉴 패턴은 ExposedDropdownMenuBox, TextField, DropdownMenu 및 DropdownMenuItem 컨트롤을 사용하여 대부분 접근 가능한 드롭다운 선택 메뉴를 만듭니다. 그러나 키보드 작동은 제외됩니다.</string>
    <string name="exposed_dropdown_menus_example_2_heading">문제가 되는 예시 2: 뷰 기반 편집 불가능한 노출된 드롭다운 메뉴</string>
    <string name="exposed_dropdown_menus_example_2_description">AndroidView에 뷰 노출 드롭다운 메뉴 패턴을 래핑하면 대부분 접근 가능합니다. 하지만 Compose/뷰 상호 운용 문제로 인해 키보드로 접근할 수 없습니다.</string>
    <string name="exposed_dropdown_menus_example_label">결제 방법</string>
    <string name="exposed_dropdown_menus_example_option_1">현금</string>
    <string name="exposed_dropdown_menus_example_option_2">수표</string>
    <string name="exposed_dropdown_menus_example_option_3">신용/직불카드</string>
    <string name="exposed_dropdown_menus_example_option_4">송금 수단</string>
    <string name="exposed_dropdown_menus_example_option_5">상품권</string>
    <string name="exposed_dropdown_menus_example_option_not_selected">(결제 방법 미선택)</string>
        <!-- Links inline with text -->
    <string name="inline_links_title">텍스트 인라인 링크</string>
    <string name="inline_links_heading">인라인 링크를 독립형 링크와 다르게 생성하세요</string>
    <string name="inline_links_description_1">텍스트 인라인 링크는 AnnotatedString 및 ClickableText를 사용하여 생성할 수 있습니다. 링크는 TalkBack 메뉴의 링크 대화 상자에 나타납니다.</string>
    <string name="inline_links_description_2">TalkBack을 켜고 페이지 텍스트를 탐색하여 데모를 보세요. 인라인 링크 텍스트 주위의 멈춤을 확인하세요. "링크 사용 가능" 액션 알림을 들어보세요. 세 손가락으로 탭하여 TalkBack 메뉴를 열고, "링크"를 선택하여 사용 가능한 링크가 포함된 대화 상자를 보세요. 링크를 선택하여 브라우저에서 링크된 페이지를 엽니다.</string>
    <string name="inline_links_example_1">문제가 되는 예시 1: AnnotatedString 및 ClickableText 사용</string>
    <string name="inline_links_example_1_text">이 단락은 고정 링크 텍스트 값을 사용한 AnnotatedString 및 ClickableText를 사용하여 인라인 링크의 간단한 예시입니다.</string>
    <string name="inline_links_example_1_link_text_1">인라인 링크</string>
    <string name="inline_links_example_1_link_text_2">AnnotatedString</string>
    <string name="inline_links_example_1_link_text_3">ClickableText</string>
    <string name="inline_links_example_1_note">참고: 이러한 링크는 보조 기술과 잘 작동하지만 키보드로는 접근할 수 없습니다.</string>
    <string name="inline_links_example_2">문제가 되는 예시 2: AndroidView 및 TextView 사용</string>
    <string name="inline_links_example_2_text">현재 접근성을 위해, ClickableText 대신 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/viewinterop/package-summary#AndroidView(kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Function1)">AndroidView</a>와 <a href="https://github.com/cvs-health/android-view-accessibility-techniques/blob/main/doc/componenttypes/LinksInlineWithText.md">TextView 링크</a>를 사용하세요.</string>
    <string name="inline_links_example_2_note">이 단락은 보조 기술과 작동합니다. 하지만 Compose/뷰 상호 운용 문제로 인해 키보드로 접근할 수 없습니다. 만약 작동한다면, 탐색 화살표 키가 포커스된 텍스트 블록 내에서 링크에 포커스를 맞출 것입니다.</string>
        <!-- ListItem layouts -->
    <string name="listitem_layouts_title">ListItem 레이아웃</string>
    <string name="listitem_layouts_heading">표준 ListItem 레이아웃은 접근 가능합니다</string>
    <string name="listitem_layouts_description_1">ListItem 레이아웃은 후손을 병합합니다.</string>
    <string name="listitem_layouts_description_2">TalkBack을 켜고 페이지를 탐색하며 ListItem 레이아웃의 데모를 보십시오.</string>
    <string name="listitem_layouts_example_1_header">좋은 예시 1: 접근 가능한 비활성 ListItem 레이아웃</string>
    <string name="listitem_layouts_example_1_label">접근 가능한 비활성 ListItem</string>
    <string name="listitem_layouts_example_1_subtitle">단일 텍스트로 발표됨.</string>
    <string name="listitem_layouts_example_2_header">좋은 예시 2: 접근 가능한 클릭 가능한 ListItem 레이아웃</string>
    <string name="listitem_layouts_example_2_label">접근 가능한 클릭 가능한 ListItem</string>
    <string name="listitem_layouts_example_2_subtitle">단일 레이블이 달린 클릭 가능한 버튼으로 발표됨.</string>
    <string name="listitem_layouts_example_2_message">접근 가능한 클릭 가능한 ListItem 클릭됨</string>
    <string name="listitem_layouts_example_3_header">좋은 예시 3: 접근 가능한 선택 가능한 ListItem 레이아웃</string>
    <string name="listitem_layouts_example_3_label_1">접근 가능한 선택 가능한 ListItem 1</string>
    <string name="listitem_layouts_example_3_subtitle_1">레이블이 달린 첫 번째 선택 가능한 라디오 버튼으로 발표됨.</string>
    <string name="listitem_layouts_example_3_label_2">접근 가능한 선택 가능한 ListItem 2</string>
    <string name="listitem_layouts_example_3_subtitle_2">레이블이 달린 두 번째 선택 가능한 라디오 버튼으로 발표됨.</string>
    <string name="listitem_layouts_example_4_header">좋은 예시 4: 접근 가능한 토글 가능한 ListItem 레이아웃</string>
    <string name="listitem_layouts_example_4_label">접근 가능한 토글 가능한 ListItem</string>
    <string name="listitem_layouts_example_4_subtitle">단일 레이블이 달린 토글 가능한 스위치로 발표됨.</string>
        <!-- ModalBottomSheet layouts -->
    <string name="modalbottomsheet_layouts_title">ModalBottomSheet 레이아웃</string>
    <string name="modalbottomsheet_layouts_heading">ModalBottomSheet 레이아웃은 키보드 수정이 필요합니다</string>
    <string name="modalbottomsheet_layouts_description_1">ModalBottomSheet 레이아웃은 기본적으로 완전히 접근 가능하지 않습니다. 제목, 더 나은 그랩 바 설명, 하단 패딩 및 키보드 문제를 피하기 위한 수정이 필요합니다.</string>
    <string name="modalbottomsheet_layouts_description_2">TalkBack을 켜고 페이지를 탐색하며 ModalBottomSheet 레이아웃의 데모를 보십시오.</string>
    <string name="modalbottomsheet_layouts_description_3">또한, 키보드 네비게이션을 사용해 Esc 키와 포커스 관리가 어떻게 작동하는지 테스트해보십시오.</string>
    <string name="modalbottomsheet_layouts_example_1_header">좋은 예시 1: ModalBottomSheet 선택기</string>
    <string name="modalbottomsheet_layouts_example_1_button_1">반쯤 열린 바텀 시트에서 과일 선택</string>

    <string name="modalbottomsheet_layouts_example_1_button_2">완전히 열린 바텀 시트에서 과일 선택</string>
    <string name="modalbottomsheet_layouts_example_1_selected_item">선택된 과일: %1$s</string>
    <string name="modalbottomsheet_layouts_sheet_title">과일 선택</string>
    <string name="modalbottomsheet_layouts_sheet_drag_handle_description">과일 선택 바텀 시트 드래그 핸들</string>
    <string name="modalbottomsheet_layouts_item_1">사과</string>
    <string name="modalbottomsheet_layouts_item_2">살구</string>
    <string name="modalbottomsheet_layouts_item_3">바나나</string>
    <string name="modalbottomsheet_layouts_item_4">블루베리</string>
    <string name="modalbottomsheet_layouts_item_5">체리</string>
    <string name="modalbottomsheet_layouts_item_6">대추야자</string>
    <string name="modalbottomsheet_layouts_item_7">두리안</string>
    <string name="modalbottomsheet_layouts_item_8">엘더베리</string>
    <string name="modalbottomsheet_layouts_item_9">무화과</string>
    <string name="modalbottomsheet_layouts_item_10">포도</string>
    <string name="modalbottomsheet_layouts_item_11">구아바</string>
    <string name="modalbottomsheet_layouts_item_12">허니듀 멜론</string>
    <string name="modalbottomsheet_layouts_item_13">잭프루트</string>
    <string name="modalbottomsheet_layouts_item_14">키위</string>
    <string name="modalbottomsheet_layouts_item_15">라임</string>
    <string name="modalbottomsheet_layouts_item_16">리치</string>
    <string name="modalbottomsheet_layouts_item_17">망고</string>
    <string name="modalbottomsheet_layouts_item_18">넥타린</string>
    <string name="modalbottomsheet_layouts_item_19">오렌지</string>
    <string name="modalbottomsheet_layouts_item_20">파파야</string>
    <string name="modalbottomsheet_layouts_item_21">복숭아</string>
    <string name="modalbottomsheet_layouts_item_22">라즈베리</string>
    <string name="modalbottomsheet_layouts_item_23">딸기</string>
    <string name="modalbottomsheet_layouts_item_24">타마린드</string>
    <string name="modalbottomsheet_layouts_item_25">우글리 프루트</string>
    <string name="modalbottomsheet_layouts_item_26">수박</string>
    <string name="modalbottomsheet_layouts_item_27">시과(Xigua)</string>
    <string name="modalbottomsheet_layouts_item_28">양매(Yangmei)</string>
    <!-- NavigationBar 레이아웃 -->
    <string name="navigationbar_layouts_title">네비게이션바 레이아웃</string>
    <string name="navigationbar_layouts_heading">콘텐츠가 좋다면 네비게이션바 레이아웃은 잘 작동합니다</string>
    <string name="navigationbar_layouts_description_1">네비게이션바 레이아웃은 고정된 탭 행과 유사하게 작동하며: 기본적으로 완전히 접근 가능하지만 문제 있는 항목 콘텐츠에 민감합니다. 레이블 텍스트에 maxLines 또는 고정 높이를 피하세요.</string>
    <string name="navigationbar_layouts_description_2">긴 홈 네비게이션 항목 레이블이 어떻게 처리되는지 확인하세요. 그런 다음 TalkBack, Switch Access 및 외부 키보드를 사용하여 네비게이션바 레이아웃 접근성을 시연하는 페이지를 탐색하세요.</string>
    <string name="navigationbar_layouts_example_1_header">나쁜 예시 1: 텍스트 라인이 제한된 네비게이션바 레이아웃</string>
    <string name="navigationbar_layouts_example_2_header">좋은 예시 2: 텍스트 가공이 있는 네비게이션바 레이아웃</string>
    <string name="navigationbar_layouts_example_3_header">적절한 예시 3: 선택된 항목만 레이블이 있는 네비게이션바 레이아웃</string>
    <string name="navigationbar_layouts_tab_1_label">홈: 긴 레이블 예시</string>
    <string name="navigationbar_layouts_tab_2_label">즐겨찾기</string>
    <string name="navigationbar_layouts_tab_3_label">알림</string>
    <string name="navigationbar_layouts_tab_4_label">설정</string>
    <string name="navigationbar_layouts_tab_1_description_1">홈 화면 자리 표시자. 네비게이션바 항목 텍스트가 어떻게 잘리는지(또는 잘리지 않는지) 유의하세요.</string>
    <string name="navigationbar_layouts_tab_2_description_1">즐겨찾기 화면 자리 표시자.</string>
    <string name="navigationbar_layouts_tab_3_description_1">알림 화면 자리 표시자.</string>
    <string name="navigationbar_layouts_tab_4_description_1">설정 화면 자리 표시자.</string>
        <!-- Pop-up 메시지: Toasts, Snackbars, and AlertDialogs -->
    <string name="popup_messages_title">팝업 메시지</string>
    <string name="popup_messages_heading">팝업 메시지는 상충하는 요소들이 있습니다</string>
    <string name="popup_messages_description_1">팝업 메시지를 표시하는 세 가지 컨트롤이 있습니다: Toasts, Snackbars, and AlertDialogs. 팝업 대신 화면 내 텍스트를 사용하는 옵션도 존재합니다.</string>
    <string name="popup_messages_description_2">각각의 팝업 컨트롤은 장단점이 있습니다. Toasts는 잠시만 나타납니다. Snackbars는 더 유연하지만, 그 동작 버튼은 거의 접근할 수 없습니다. AlertDialogs는 방해가 될 수 있지만, 그 동작 버튼은 매우 접근하기 쉽습니다. 어떤 컨트롤을 사용할지는 디자인 트레이드오프입니다.</string>
    <string name="popup_messages_description_3">TalkBack을 켜고 페이지를 탐색하며 팝업 메시지 옵션을 시연하기 위해 버튼을 활성화하세요.</string>
    <string name="popup_messages_example_1_header">예시 1: Toast 메시지</string>
    <string name="popup_messages_example_1_description_1">Toast 메시지는 약간 나타나는 팝업 메시지로 Material Design에 앞서 존재합니다. Toasts는 나타날 때 TalkBack에 의해 자동으로 발표됩니다. Toasts는 동작을 포함할 수 없으며 수동으로 해제할 수 없습니다.</string>
    <string name="popup_messages_example_1_description_2">Toasts는 짧은 지속 시간과 다른 콘텐츠를 숨기기 때문에 일부 사용자에게 어려움을 초래합니다.</string>
    <string name="popup_messages_example_1_button_label">Toast 메시지 표시</string>
    <string name="popup_messages_example_1_message">이것은 Toast 메시지입니다. 기다리면 자동으로 닫힙니다.</string>
    <string name="popup_messages_example_2_header">예시 2: 고정된 지속 시간의 Snackbar</string>
    <string name="popup_messages_example_2_description_1">Snackbars는 Material Design의 Toast 대체품입니다. 잠시 또는 무기한 나타날 수 있으며, 동작 버튼을 포함할 수 있습니다. Snackbars는 나타날 때 TalkBack에 의해 자동으로 발표됩니다. 그러나 모달이 아니며 동작 버튼은 접근하기 매우 어렵습니다.</string>
    <string name="popup_messages_example_2_description_2">고정된 지속 시간의 Snackbars는 짧은 외관 때문에 일부 사용자에게 어려움을 초래하며 다른 콘텐츠를 숨깁니다.</string>
    <string name="popup_messages_example_2_button_label">고정된 지속 시간의 Snackbar 표시</string>
    <string name="popup_messages_example_2_message">이것은 해제 버튼이 없는 고정된 지속 시간의 Snackbar입니다. 기다리면 자동으로 닫힙니다.</string>
    <string name="popup_messages_example_3_header">예시 3: 고정된 지속 시간, 해제 가능한 Snackbar</string>
    <string name="popup_messages_example_3_description_1">Snackbars는 해제 아이콘 버튼을 표시하여 콘텐츠를 노출할 수 있는 옵션을 제공합니다. 이 버튼은 보조 기술로 접근하기 어렵지만, 시간 제한된 지속 시간은 사용 가능한 대안을 제공합니다.</string>
    <string name="popup_messages_example_3_button_label">고정된 지속 시간, 해제 가능한 Snackbar 표시</string>
    <string name="popup_messages_example_3_message">이것은 고정된 지속 시간, 해제 가능한 Snackbar입니다. 잠시 기다리거나 해제 아이콘 버튼을 선택하여 이 팝업을 닫으세요.</string>
    <string name="popup_messages_example_4_header">예시 4: 컨텍스트적 동작 버튼이 있는 고정된 지속 시간의 Snackbar</string>
    <string name="popup_messages_example_4_description">고정된 지속 시간의 Snackbar는 "실행 취소"와 같은 컨텍스트적 동작을 수행할 수 있는 옵션을 제공할 수 있습니다. 그러나 동작 버튼은 대부분의 보조 기술로 접근할 수 없으며, 신속하게 접근할 수 없습니다. 이 디자인은 일부 사람들에게 사용 불가합니다.</string>
    <string name="popup_messages_example_4_button_label">컨텍스트적 동작 버튼이 있는 고정된 지속 시간의 Snackbar 표시</string>
    <string name="popup_messages_example_4_message">이것은 동작 버튼이 있는 고정된 지속 시간의 Snackbar입니다. 잠시 기다려 닫으세요. "더 보기" 버튼을 선택하여 다른 메시지를 표시하세요.</string>
    <string name="popup_messages_example_4_message_action_label">더 보기</string>
    <string name="popup_messages_example_4_action_message">"더 보기" 동작 버튼을 선택했습니다.</string>
    <string name="popup_messages_example_5_header">예시 5: 무기한 지속 시간, 해제 가능한 Snackbar</string>
    <string name="popup_messages_example_5_description_1">무기한 지속 시간의 Snackbars는 너무 짧은 메시지 문제를 해결하지만, Snackbar의 해제 동작 버튼 사용이 필요한 비용을 수반하며, 이는 접근하기 거의 불가능합니다.</string>
    <string name="popup_messages_example_5_description_2">이 형태의 Snackbar가 나타나면 TalkBack은 포커스를 변경하여 발표를 방해할 수 있습니다.</string>
    <string name="popup_messages_example_5_button_label">무기한 지속 시간, 해제 가능한 Snackbar 표시</string>
    <string name="popup_messages_example_5_message">이것은 무기한 지속 시간, 해제 가능한 Snackbar입니다. 해제 아이콘 버튼을 선택하여 이 팝업을 닫으세요.</string>
    <string name="popup_messages_example_6_header">예시 6: 동작 버튼이 있는 AlertDialog</string>
    <string name="popup_messages_example_6_description">AlertDialogs는 화면 컨텍스트를 변경하는 팝업 모달 다이얼로그로, 혼란을 초래할 수 있습니다. 그러나 AlertDialog의 첫 번째 콘텐츠 요소는 TalkBack에 의해 자동으로 발표되며, AlertDialog 동작 버튼은 접근하기 쉽습니다.</string>
    <string name="popup_messages_example_6_button_label">동작 버튼이 있는 AlertDialog 표시</string>
    <string name="popup_messages_example_6_alert_title">동작 버튼이 있는 AlertDialog</string>
    <string name="popup_messages_example_6_message">"더 보기"를 선택하여 더 많은 AlertDialog를 확인하세요. "확인" 버튼을 선택하여 이 팝업을 닫으세요.</string>
    <string name="popup_messages_example_6_show_more_label">더 보기</string>
    <string name="popup_messages_example_6_dismiss_label">닫기</string>
    <string name="popup_messages_example_6_action_popup_title">더 많은 AlertDialog 표시</string>
    <string name="popup_messages_example_6_action_popup_message">"더 보기" 동작 버튼을 선택했습니다.</string>
    <string name="popup_messages_example_6_action_popup_dismiss_label">확인</string>
    <string name="popup_messages_example_7_header">예시 7: 화면 상의 텍스트 메시지와 버튼</string>
    <string name="popup_messages_example_7_description">화면 상의 텍스트를 사용하여 상태 메시지를 발표하고 컨텍스트적 동작을 제시할 수 있습니다.</string>
    <string name="popup_messages_example_7_button_label">화면 상의 텍스트 값을 변경</string>
    <string name="popup_messages_example_7_message">카운터: %1$d</string>
    <string name="popup_messages_example_7_clear_label">지우기</string>
    <string name="popup_messages_example_7_clear_content_description">카운터 지우기</string>
        <!-- RadioButton 그룹 -->
    <string name="radio_button_groups_title">RadioButton 그룹</string>
    <string name="radio_button_groups_heading">RadioButton 그룹은 selectableGroup 수정자가 필요합니다; RadioButtons는 레이블이 필요합니다</string>
    <string name="radio_button_groups_description_1">RadioButton composables를 그룹화하는 레이아웃 composables는 Modifier.selectableGroup()이 필요합니다. 개별 RadioButton composables는 그들의 시맨틱를 포괄하고 제어 레이블을 제공하는 래핑 레이아웃이 필요합니다.</string>
    <string name="radio_button_groups_description_2">TalkBack을 켜고 페이지를 탐색하며 접근 불가능한 RadioButton 그룹과 접근 가능한 RadioButton 그룹의 시연을 위해 컨트롤을 활성화하세요.</string>
    <string name="radio_button_groups_example_1_header">예시 1: 접근 불가능한 RadioButton 그룹</string>
    <string name="radio_button_groups_example_2_header">접근 가능한 RadioButton; 접근 불가능한 그룹</string>
    <string name="radio_button_groups_example_2_description">이 RadioButtons는 적절하게 수정되었습니다. 그러나 RadioButton 그룹에는 selectableGroup 수정자가 없습니다.</string>
    <string name="radio_button_groups_example_3_header">예시 3: 접근 가능한 RadioButton 그룹</string>
    <string name="radio_button_groups_group_label">과일 선택:</string>
    <string name="radio_button_groups_option_1">바나나</string>
    <string name="radio_button_groups_option_2">포도</string>
    <string name="radio_button_groups_option_3">오렌지</string>
        <!-- Slider 및 RangeSlider 컨트롤 -->
    <string name="slider_controls_title">Slider 및 RangeSlider 컨트롤</string>
    <string name="slider_controls_heading">Slider 및 RangeSlider는 수정이 필요합니다</string>
    <string name="slider_controls_description_1">Slider 컨트롤은 레이블링, 상태 발표 및 키보드 작동을 위한 특정 수정을 통해 완전히 접근 가능하게 만들 수 있습니다. RangeSlider는 TalkBack을 위한 유사한 수정이 필요하지만, 현재 키보드 접근성 문제에 대한 수정은 알려져 있지 않습니다.</string>
    <string name="slider_controls_description_2">TalkBack 또는 Switch Access를 켜고 페이지를 탐색하며 Slider 및 RangeSlider 컨트롤의 시연을 위해 컨트롤을 활성화하세요. RangeSlider 컨트롤은 키보드 접근이 불가능함을 유의하세요.</string>
    <string name="slider_controls_example_1_header">예시 1: 수정되지 않은 Slider 컨트롤</string>
    <string name="slider_controls_example_1_description">수정 없이 Slider는 TalkBack에서 레이블이나 상태를 적절하게 발표하지 않습니다.</string>
    <string name="slider_controls_example_1_label">평가</string>
    <string name="slider_controls_example_2_header">예시 2: 수정된 Slider 컨트롤</string>
    <string name="slider_controls_example_2_description">Sliders는 접근 가능한 레이블을 제공하기 위해 contentDescription 사용이 필요합니다. TalkBack에서 적절한 상태 발표를 위해 stateDescription 및 liveRegion 시맨틱가 필요합니다. 키보드 접근성을 위해 키 처리 수정이 필요합니다.</string>
    <string name="slider_controls_example_2_label">평가</string>
    <string name="slider_controls_example_3_header">예시 3: 키보드 접근이 불가능한 수정된 RangeSlider</string>
    <string name="slider_controls_example_3_description">Sliders와 마찬가지로, RangeSliders는 접근 가능한 레이블을 제공하기 위해 contentDescription이 필요하며, TalkBack에서 좋은 상태 발표를 위해 시맨틱 변경이 필요합니다. 그러나 현재 키보드 접근성 문제에 대한 수정은 알려져 있지 않습니다.</string>
    <string name="slider_controls_example_3_label">평가 필터 범위</string>
    <string name="slider_controls_example_3_content_description">평가 필터 범위</string>
    <string name="slider_controls_example_3_state_description">%1$d에서 %2$d까지</string>
    <string name="slider_controls_example_4_header">예시 4: 키보드 접근이 불가능한 View RangeSlider</string>
    <string name="slider_controls_example_4_description">AndroidView에 감싸진 View RangeSlider는 Compose/View 상호 운용성 문제로 키보드 접근이 불가능합니다.</string>
    <string name="slider_controls_example_4_label">평가 필터 범위</string>
    <string name="slider_controls_example_4_content_description">평가 필터 범위</string>
    <string name="slider_controls_example_4_selected_range">포함된 평가: %1$d에서 %2$d까지</string>
        <!-- 독립형 링크 -->
    <string name="standalone_links_title">독립형 링크</string>
    <string name="standalone_links_heading">독립형 링크는 onClickLabel 등이 필요합니다</string>
    <string name="standalone_links_description_1">Android에는 링크를 버튼이나 다른 클릭 가능한 요소와 구별하기 위한 "link" 역할이 없습니다. 하지만 독립형 링크를 사용자에게 이해할 수 있도록 만드는 데 필요한 몇 가지 사항이 있습니다.</string>
    <string name="standalone_links_description_2">TalkBack을 켜고 페이지를 탐색하며 더 접근 가능한 독립형 링크와 덜 접근 가능한 독립형 링크의 시연을 위해 링크를 활성화하세요.</string>
    <string name="standalone_links_example_1_header">예시 1: 구별할 수 없는 텍스트 링크</string>
    <string name="standalone_links_example_1_text">이 텍스트가 링크임을 나타내는 것이 없으며, 텍스트가 링크가 어디로 가는지 설명하지도 않습니다. 이 링크는 여러 접근성 지침을 충족하지 못합니다.</string>
    <string name="standalone_links_example_2_header">예시 2: 접근 가능한 독립형 링크 텍스트</string>
    <string name="standalone_links_example_2_description">접근 가능한 독립형 링크를 만들기 위해서는 링크의 목적지를 설명하고, 구별되는 링크 스타일을 사용하며, 클릭 동작이 브라우저 창을 열 것임을 나타내기 위해 onClickLabel을 적용해야 합니다. "행동 촉구(call to action)" 문구를 사용하는 것도 좋은 방법입니다.</string>
    <string name="standalone_links_example_2_text">Jetpack Compose 접근성에 대해 읽어보기</string>
    <string name="standalone_links_example_3_header">좋은 예시 3: 아이콘이 있는 접근 가능한 독립형 링크</string>
    <string name="standalone_links_example_3_text">Jetpack Compose 접근성에 대해 읽어보기</string>
    <string name="standalone_links_example_4_header">좋은 예시 4: onClickLabel이 있는 Stand-alone link TextButton</string>
    <string name="standalone_links_example_4_text">Jetpack Compose 접근성에 대해 읽어보기</string>

    <!-- Switch controls -->
    <string name="switch_controls_title">스위치 컨트롤</string>
    <string name="switch_controls_heading">스위치 컨트롤은 레이블과 Modifier.toggleable이 필요합니다</string>
    <string name="switch_controls_description_1">스위치 composables는 그 시맨틱를 포괄하는 래핑 레이아웃(Modifier.toggleable과 Role.Switch 사용)을 요구하며, 제어 레이블을 제공합니다.</string>
    <string name="switch_controls_description_2">TalkBack을 켜고 페이지를 탐색하며 접근 불가능한 스위치 그룹과 접근 가능한 스위치 그룹의 시연을 위해 컨트롤을 활성화하세요.</string>
    <string name="switch_controls_example_1_header">나쁜 예시 1: 접근 불가능한 스위치</string>
    <string name="switch_controls_example_1_label">가짜 스위치</string>
    <string name="switch_controls_example_2_header">좋은 예시 2: 접근 가능한 스위치</string>
    <string name="switch_controls_example_2_label">접근 가능한 스위치</string>

    <!-- Tab rows -->
    <string name="tab_rows_title">탭 행</string>
    <string name="tab_rows_heading">고정된 탭 행은 작동하지만, 스크롤 가능한 탭 행은 문제가 있습니다</string>
    <string name="tab_rows_description_1">모든 탭 행 composables은 탭 위젯을 페이지의 다른 콘텐츠를 제어하는 단일 선택 행으로 모읍니다. 고정된 TabRow composables은 동일한 너비의 탭을 표시합니다. 스크롤 가능한 TabRow composables은 필요 시 추가 탭을 표시하기 위해 다른 너비의 탭을 허용하며 스크롤됩니다.</string>
    <string name="tab_rows_description_2">고정된 탭 행은 기본적으로 접근 가능하지만, 문제 있는 탭 레이블에 민감합니다.</string>
    <string name="tab_rows_description_3">Switch Access를 사용하여 페이지를 탐색하고, TalkBack을 다시 한 번 사용하여 탭 접근성 예시를 확인하세요. 첫 번째 긴 탭 레이블이 어떻게 처리되는지 유의하세요.</string>
    <string name="tab_rows_example_1_header">나쁜 예시 1: 텍스트 라인이 제한된 고정된 TabRow</string>
    <string name="tab_rows_example_2_header">좋은 예시 2: 텍스트 가공이 있는 고정된 TabRow</string>
    <string name="tab_rows_example_3_header">적절한 예시 3: 스크롤 가능한 TabRow</string>
    <string name="tab_rows_example_3_description">TalkBack에서 스크롤 가능한 TabRows는 탭 콘텐츠에서 스크롤된 탭 행으로 다시 스와이프할 때 어려움을 초래합니다. Switch Access에서는 스크롤 가능한 TabRow의 스크롤 영역이 페이지 탐색 순서에서 너무 일찍 나타납니다. 이는 관련 라이브러리의 이후 버전에서 해결될 수 있는 플랫폼 문제입니다.</string>
    <string name="tab_rows_example_4_header">적절한 예시 4: 페이징 콘텐츠가 있는 TabRow</string>
    <string name="tab_rows_example_4_description">TabRow 탭 선택은 HorizontalPager의 탭 콘텐츠와 조정될 수 있습니다. Switch Access에서는 HorizontalPager의 스크롤 영역이 페이지 탐색 순서에서 너무 일찍 나타납니다. TalkBack에서는 탭 콘텐츠가 수직 페이저에 있다고 발표됩니다. 다시 말해, 이는 플랫폼 문제입니다.</string>
    <string name="tab_rows_tab_1">탭 1: 긴 레이블</string>
    <string name="tab_rows_tab_2">탭 2</string>
    <string name="tab_rows_tab_3">탭 3</string>
    <string name="tab_rows_tab_4">탭 4</string>
    <string name="tab_rows_tab_5">탭 5</string>
    <string name="tab_rows_tab_1_content">탭 1 콘텐츠</string>
    <string name="tab_rows_tab_2_content">탭 2 콘텐츠</string>
    <string name="tab_rows_tab_3_content">탭 3 콘텐츠</string>
    <string name="tab_rows_tab_4_content">탭 4 콘텐츠</string>
    <string name="tab_rows_tab_5_content">탭 5 콘텐츠</string>
    <!-- TextField controls -->
    <string name="textfield_controls_title">텍스트 필드 컨트롤</string>
    <string name="textfield_controls_heading">텍스트 필드 컨트롤은 키보드 트랩 등 수정이 필요합니다</string>
    <string name="textfield_controls_description_1">텍스트 필드 컨트롤은 레이블이 필요하며, 키보드 탭 처리를 제대로 수행하기 위한 Modifier 수정, 적절한 오류 처리, 적절한 자동 채우기, 맞는 키보드 타입, 옵션, 동작이 필요합니다.</string>
    <string name="textfield_controls_description_2">TalkBack을 켜고 페이지를 탐색하며 접근 가능한 텍스트 필드의 시연을 위해 컨트롤을 활성화하세요.</string>
    <string name="textfield_controls_example_1_header">좋은 예시 1: 접근 가능한 필수 텍스트 필드</string>
    <string name="textfield_controls_example_1_label">이름</string>
    <string name="textfield_controls_example_1_supporting_text">공백이 아닌 이름이 필요합니다.</string>
    <string name="textfield_controls_example_1_button">제출</string>
    <string name="textfield_controls_example_1_short_error">이름이 필요합니다. 공백이 아닌 이름을 입력해주세요.</string>
    <string name="textfield_controls_example_1_long_error">오류: 이름이 필요합니다. 공백이 아닌 이름을 입력해주세요.</string>
    <string name="textfield_controls_example_1_message">텍스트 필드 값 %1$s 제출됨.</string>
</resources>